<!DOCTYPE html>
<html>
<head>
<script src="https://peterolson.github.com/BigInteger.js/BigInteger.min.js"></script>
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script type="text/javascript" src="https://cdn.rawgit.com/ricmoo/aes-js/e27b99df/index.js"></script>
<script>

	function u32(x) {
		return bigInt(x).and(0xFFFFFFFF)
	}

	class sead_rand {
		constructor(states) {
			this.state = []
			for(var i = 1; i < 5; i++){
				this.state[i-1] = states[i-1]
			}
		}

		get_u32() {
			var a = u32(bigInt(this.state[0]).xor(bigInt(this.state[0]).shiftLeft(11)))
			this.state[0] = this.state[1]
			var b = u32(this.state[3])
			var c = u32(bigInt(a).xor((bigInt(a).shiftRight(8))).xor(b).xor(bigInt(b).shiftRight(19)))
			this.state[1] = this.state[2]
			this.state[2] = b
			this.state[3] = c
			return c
		}
	}
	
  function handleFileSelect()
  {               
    if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
      alert('The File APIs are not fully supported in this browser.');
      return;
    }   

    input = document.getElementById('fileinput');
    if (!input) {
      alert("Um, couldn't find the fileinput element.");
    }
    else if (!input.files) {
      alert("This browser doesn't seem to support the `files` property of file inputs.");
    }
    else if (!input.files[0]) {
      alert("Please select a file before clicking 'Load'");               
    }
    else {
      file = input.files[0];
      fr = new FileReader();
      fr.onload = receivedText;
      //fr.readAsText(file);
      fr.readAsArrayBuffer(file);
    }
  }
  
  function decimalToHex(d, padding) {
    var hex = Number(d).toString(16);
    padding = typeof (padding) === "undefined" || padding === null ? padding = 2 : padding;

    while (hex.length < padding) {
        hex = "0" + hex;
    }

    return hex;
}
  
  function get16bytes(Array,startPos) {
	var endStr = ""
	for(i = 0; i < 16; i++){
		endStr += decimalToHex(Array[startPos + i], 2);	
	}
	return endStr;
  }
  
  function getArray(Src, startPos, Count) {
	var endArray = []
	for(i = 0; i < Count; i++){
		endArray[i] = Src[startPos + i];	
	}
	return endArray; 
  }
  
  function readInt32(array, startPos) {
	var newArr = [array[startPos + 3],array[startPos + 2],array[startPos + 1],array[startPos]]
    var result=0;
    for (let i=3;i>=0;i--) {
        result+=newArr[3-i]<<(8*i);
    }
    return result;
};

  function receivedText() {
	var JSstruct = new JSPack();
	var Uint8File = new Uint8Array(fr.result);
	var MAC = getArray(Uint8File,0x000088D80, 0x10);
	var KeySeed = getArray(Uint8File,0x000088D70, 0x10);
	var IV = getArray(Uint8File,0x000088D60, 0x10);
	var body = Uint8File.slice(0x10, Uint8File.length - 0x30);
	
	rnd = new sead_rand(JSstruct.Unpack("<IIII",KeySeed,0));
	
	crypt_tab = [0xDFD0A132,  0x1537D7E5,  0xC8B0F6D5,  0x6C31FED3,  0xB7A1221A,  0x9B9DC40C,  0x44315579,  0xF239E05A,  0x87E4D9AF,  0x59EF5961,  0xF5AF2DC9,  0xD1521C02,  0x68405262,  0x9864C589,  0x98F5F8BE,  0x0C90FE24,  0x9B3FC02A,  0x31E4FD02,  0xEC747B2D,  0x5FC1C04E,  0x80D6B732,  0x32BA6CB7,  0x961A5683,  0x33025098,  0xD5676789,  0xAB622A5A,  0xF651F93A,  0x130D6D68,  0xEFFEDA48,  0x24E2C2D3,  0xEA89C5DD,  0xF04AFA58,  0x767D3A19,  0xBF67B888,  0x54218F00,  0x6F461AFF,  0x9A216E37,  0x5861AAD0,  0x3B44CEAE,  0xCD6C9A42,  0x0610ECD2,  0x2A894F76,  0x23D72BE9,  0x63FA2D93,  0x2ADC8A10,  0xFB0E9F6A,  0x3BE0CE91,  0x80BB93A1,  0xDB8D8FF3,  0x72E21DC7,  0x93B0C670,  0x2907C541,  0x3DBF1C6D,  0x62D8924F,  0x3205E36F,  0x041C44D5,  0xDACB2490,  0x01D905A9,  0x6C8C579B,  0xE3C54DC2,  0xF4583808,  0x76459488,  0x1E5F7C61,  0x2876F360]
	
	var key = []
    for (a = 0; a <= 7; a++) {
        var k = u32(0)
        for (b = 0; b <= 3; b++) {
			k = bigInt(k).shiftLeft(8)
			var firstU32 = rnd.get_u32()
			var firstShift = bigInt(firstU32).shiftRight(26)
			var cryptTab = crypt_tab[firstShift]
			var secondU32 = rnd.get_u32()
			var secondShift = bigInt(secondU32).shiftRight(27)
			var firstAnd = bigInt(secondShift).and(0x18)
			var thirdShift = bigInt(cryptTab).shiftRight(firstAnd.value)
            k = bigInt(k).or(u32(bigInt(thirdShift).and(0xFF)))
		}
        key[a] = k
	}
	var AESKey = JSstruct.Pack('<IIII', [key[0], key[1], key[2], key[3]])
	var MACKey = JSstruct.Pack('<IIII', [key[4], key[5], key[6], key[7]])
	
	var aesCbc = new aesjs.ModeOfOperation.cbc(AESKey, IV);
	var decryptedBytes = aesCbc.decrypt(body);
	console.log(readInt32(decryptedBytes,0x00025788 - 0x10)) // My Money

  } 
  var myarr = [0xFF, 0x99, 0x28, 0x0F, 0x19, 0x00, 0x98]
	function JSPack()
	{
		// Module-level (private) variables
		var el,  bBE = false, m = this;


		// Raw byte arrays
		m._DeArray = function (a, p, l)
		{
			return [a.slice(p,p+l)];
		};
		m._EnArray = function (a, p, l, v)
		{
			for (var i = 0; i < l; a[p+i] = v[i]?v[i]:0, i++);
		};

		// ASCII characters
		m._DeChar = function (a, p)
		{
			return String.fromCharCode(a[p]);
		};
		m._EnChar = function (a, p, v)
		{
			a[p] = v.charCodeAt(0);
		};

		// Little-endian (un)signed N-byte integers
		m._DeInt = function (a, p)
		{
			var lsb = bBE?(el.len-1):0, nsb = bBE?-1:1, stop = lsb+nsb*el.len, rv, i, f;
			for (rv = 0, i = lsb, f = 1; i != stop; rv+=(a[p+i]*f), i+=nsb, f*=256);
			if (el.bSigned && (rv & Math.pow(2, el.len*8-1))) { rv -= Math.pow(2, el.len*8); }
			return rv;
		};
		m._EnInt = function (a, p, v)
		{
			var lsb = bBE?(el.len-1):0, nsb = bBE?-1:1, stop = lsb+nsb*el.len, i;
			v = (v<el.min)?el.min:(v>el.max)?el.max:v;
			for (i = lsb; i != stop; a[p+i]=v&0xff, i+=nsb, v>>=8);
		};

		// ASCII character strings
		m._DeString = function (a, p, l)
		{
			for (var rv = new Array(l), i = 0; i < l; rv[i] = String.fromCharCode(a[p+i]), i++);
			return rv.join('');
		};
		m._EnString = function (a, p, l, v)
		{
			for (var t, i = 0; i < l; a[p+i] = (t=v.charCodeAt(i))?t:0, i++);
		};

		// Little-endian N-bit IEEE 754 floating point
		m._De754 = function (a, p)
		{
			var s, e, m, i, d, nBits, mLen, eLen, eBias, eMax;
			mLen = el.mLen, eLen = el.len*8-el.mLen-1, eMax = (1<<eLen)-1, eBias = eMax>>1;

			i = bBE?0:(el.len-1); d = bBE?1:-1; s = a[p+i]; i+=d; nBits = -7;
			for (e = s&((1<<(-nBits))-1), s>>=(-nBits), nBits += eLen; nBits > 0; e=e*256+a[p+i], i+=d, nBits-=8);
			for (m = e&((1<<(-nBits))-1), e>>=(-nBits), nBits += mLen; nBits > 0; m=m*256+a[p+i], i+=d, nBits-=8);

			switch (e)
			{
				case 0:
					// Zero, or denormalized number
					e = 1-eBias;
					break;
				case eMax:
					// NaN, or +/-Infinity
					return m?NaN:((s?-1:1)*Infinity);
				default:
					// Normalized number
					m = m + Math.pow(2, mLen);
					e = e - eBias;
					break;
			}
			return (s?-1:1) * m * Math.pow(2, e-mLen);
		};
		m._En754 = function (a, p, v)
		{
			var s, e, m, i, d, c, mLen, eLen, eBias, eMax;
			mLen = el.mLen, eLen = el.len*8-el.mLen-1, eMax = (1<<eLen)-1, eBias = eMax>>1;

			s = v<0?1:0;
			v = Math.abs(v);
			if (isNaN(v) || (v == Infinity))
			{
				m = isNaN(v)?1:0;
				e = eMax;
			}
			else
			{
				e = Math.floor(Math.log(v)/Math.LN2);			// Calculate log2 of the value
				if (v*(c = Math.pow(2, -e)) < 1) { e--; c*=2; }		// Math.log() isn't 100% reliable

				// Round by adding 1/2 the significand's LSD
				if (e+eBias >= 1) { v += el.rt/c; }			// Normalized:  mLen significand digits
				else { v += el.rt*Math.pow(2, 1-eBias); } 		// Denormalized:  <= mLen significand digits
				if (v*c >= 2) { e++; c/=2; }				// Rounding can increment the exponent

				if (e+eBias >= eMax)
				{
					// Overflow
					m = 0;
					e = eMax;
				}
				else if (e+eBias >= 1)
				{
					// Normalized - term order matters, as Math.pow(2, 52-e) and v*Math.pow(2, 52) can overflow
					m = (v*c-1)*Math.pow(2, mLen);
					e = e + eBias;
				}
				else
				{
					// Denormalized - also catches the '0' case, somewhat by chance
					m = v*Math.pow(2, eBias-1)*Math.pow(2, mLen);
					e = 0;
				}
			}

			for (i = bBE?(el.len-1):0, d=bBE?-1:1; mLen >= 8; a[p+i]=m&0xff, i+=d, m/=256, mLen-=8);
			for (e=(e<<mLen)|m, eLen+=mLen; eLen > 0; a[p+i]=e&0xff, i+=d, e/=256, eLen-=8);
			a[p+i-d] |= s*128;
		};


		// Class data
		m._sPattern	= '(\\d+)?([AxcbBhHsfdiIlL])';
		m._lenLut	= {'A':1, 'x':1, 'c':1, 'b':1, 'B':1, 'h':2, 'H':2, 's':1, 'f':4, 'd':8, 'i':4, 'I':4, 'l':4, 'L':4};
		m._elLut	= {	'A': {en:m._EnArray, de:m._DeArray},
					's': {en:m._EnString, de:m._DeString},
					'c': {en:m._EnChar, de:m._DeChar},
					'b': {en:m._EnInt, de:m._DeInt, len:1, bSigned:true, min:-Math.pow(2, 7), max:Math.pow(2, 7)-1},
					'B': {en:m._EnInt, de:m._DeInt, len:1, bSigned:false, min:0, max:Math.pow(2, 8)-1},
					'h': {en:m._EnInt, de:m._DeInt, len:2, bSigned:true, min:-Math.pow(2, 15), max:Math.pow(2, 15)-1},
					'H': {en:m._EnInt, de:m._DeInt, len:2, bSigned:false, min:0, max:Math.pow(2, 16)-1},
					'i': {en:m._EnInt, de:m._DeInt, len:4, bSigned:true, min:-Math.pow(2, 31), max:Math.pow(2, 31)-1},
					'I': {en:m._EnInt, de:m._DeInt, len:4, bSigned:false, min:0, max:Math.pow(2, 32)-1},
					'l': {en:m._EnInt, de:m._DeInt, len:4, bSigned:true, min:-Math.pow(2, 31), max:Math.pow(2, 31)-1},
					'L': {en:m._EnInt, de:m._DeInt, len:4, bSigned:false, min:0, max:Math.pow(2, 32)-1},
					'f': {en:m._En754, de:m._De754, len:4, mLen:23, rt:Math.pow(2, -24)-Math.pow(2, -77)},
					'd': {en:m._En754, de:m._De754, len:8, mLen:52, rt:0}};

		// Unpack a series of n elements of size s from array a at offset p with fxn
		m._UnpackSeries = function (n, s, a, p)
		{
			for (var fxn = el.de, rv = [], i = 0; i < n; rv.push(fxn(a, p+i*s)), i++);
			return rv;
		};

		// Pack a series of n elements of size s from array v at offset i to array a at offset p with fxn
		m._PackSeries = function (n, s, a, p, v, i)
		{
			for (var fxn = el.en, o = 0; o < n; fxn(a, p+o*s, v[i+o]), o++);
		};

		// Unpack the octet array a, beginning at offset p, according to the fmt string
		m.Unpack = function (fmt, a, p)
		{
			// Set the private bBE flag based on the format string - assume big-endianness
			bBE = (fmt.charAt(0) != '<');

			p = p?p:0;
			var re = new RegExp(this._sPattern, 'g'), m, n, s, rv = [];
			while (m = re.exec(fmt))
			{
				n = ((m[1]==undefined)||(m[1]==''))?1:parseInt(m[1]);
				s = this._lenLut[m[2]];
				if ((p + n*s) > a.length)
				{
					return undefined;
				}
				switch (m[2])
				{
					case 'A': case 's':
						rv.push(this._elLut[m[2]].de(a, p, n));
						break;
					case 'c': case 'b': case 'B': case 'h': case 'H':
					case 'i': case 'I': case 'l': case 'L': case 'f': case 'd':
						el = this._elLut[m[2]];
						rv.push(this._UnpackSeries(n, s, a, p));
						break;
				}
				p += n*s;
			}
			return Array.prototype.concat.apply([], rv);
		};

		// Pack the supplied values into the octet array a, beginning at offset p, according to the fmt string
		m.PackTo = function (fmt, a, p, values)
		{
			// Set the private bBE flag based on the format string - assume big-endianness
			bBE = (fmt.charAt(0) != '<');

			var re = new RegExp(this._sPattern, 'g'), m, n, s, i = 0, j;
			while (m = re.exec(fmt))
			{
				n = ((m[1]==undefined)||(m[1]==''))?1:parseInt(m[1]);
				s = this._lenLut[m[2]];
				if ((p + n*s) > a.length)
				{
					return false;
				}
				switch (m[2])
				{
					case 'A': case 's':
						if ((i + 1) > values.length) { return false; }
						this._elLut[m[2]].en(a, p, n, values[i]);
						i += 1;
						break;
					case 'c': case 'b': case 'B': case 'h': case 'H':
					case 'i': case 'I': case 'l': case 'L': case 'f': case 'd':
						el = this._elLut[m[2]];
						if ((i + n) > values.length) { return false; }
						this._PackSeries(n, s, a, p, values, i);
						i += n;
						break;
					case 'x':
						for (j = 0; j < n; j++) { a[p+j] = 0; }
						break;
				}
				p += n*s;
			}
			return a;
		};

		// Pack the supplied values into a new octet array, according to the fmt string
		m.Pack = function (fmt, values)
		{
			return this.PackTo(fmt, new Array(this.CalcLength(fmt)), 0, values);
		};

		// Determine the number of bytes represented by the format string
		m.CalcLength = function (fmt)
		{
			var re = new RegExp(this._sPattern, 'g'), m, sum = 0;
			while (m = re.exec(fmt))
			{
				sum += (((m[1]==undefined)||(m[1]==''))?1:parseInt(m[1])) * this._lenLut[m[2]];
			}
			return sum;
		};
	};  

</script>
</head>
<body>


<input type="file" id="fileinput"/>
<input type='button' id='btnLoad' value='Load' onclick='handleFileSelect();'>
<div id="editor"></div>



	<font face="arial" size = "8">
	<div>The</div>
	<div>quick</div>
	<div>brown</div>
	<div>fox</div>
	<div>jumps</div>
	<div>over</div>
	<div>the</div>
	<div>lazy</div>
	<div>dog</div>
	
	
</body>
</html>